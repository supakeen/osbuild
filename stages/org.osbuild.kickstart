#!/usr/bin/python3
"""
Create an Anaconda kickstart file

Kickstart files are a way to program the Anaconda
installer.  This stage can be used to create such
a kickstart file at the location given by `path`.

Only a very limited set of available kickstart
commands are supported here.
"""

import os
import sys
from typing import Dict, List, Optional

import osbuild.api

SCHEMA = """
"additionalProperties": false,
"required": ["path"],
"properties": {
  "path": {
    "type": "string",
    "description": "Where to place the kickstart file"
  },
  "ostree": {
    "type": "object",
    "required": ["osname", "url", "ref"],
    "additionalProperties": false,
    "properties": {
      "osname": {
        "type": "string"
      },
      "url": {
        "type": "string"
      },
      "ref": {
        "type": "string"
      },
      "remote": {
        "type": "string",
        "description": "The remote to tie tie commit to"
      },
      "gpg": {
        "type": "boolean",
        "default": true
      }
    }
  },
  "post_ostree": {
    "type": "object",
    "required": ["osname", "url", "ref"],
    "additionalProperties": false,
    "properties": {
      "osname": {
        "type": "string"
      },
      "url": {
        "type": "string"
      },
      "ref": {
        "type": "string"
      },
      "remote": {
        "type": "string",
        "description": "The remote to tie the commit to"
      },
      "gpg": {
        "type": "boolean",
        "default": true
      }
    }
  },
  "liveimg": {
    "type": "object",
    "required": ["url"],
    "properties": {
      "url": {
        "type": "string"
      }
    }
  },
  "groups": {
    "type": "object",
    "additionalProperties": false,
    "description": "Keys are group names, values are objects with group info",
    "patternProperties": {
      "^[A-Za-z0-9_][A-Za-z0-9_-]{0,31}$": {
        "type": "object",
        "properties": {
          "gid": {
            "type": "number",
            "description": "GID for this group"
          }
        }
      }
    }
  },
  "users": {
    "additionalProperties": false,
    "type": "object",
    "description": "Keys are usernames, values are objects giving user info.",
    "patternProperties": {
      "^[A-Za-z0-9_][A-Za-z0-9_-]{0,31}$": {
        "type": "object",
        "properties": {
          "uid": {
            "description": "User UID",
            "type": "number"
          },
          "gid": {
            "description": "User GID",
            "type": "number"
          },
          "groups": {
            "description": "Array of group names for this user",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "description": "User account description (or full name)",
            "type": "string"
          },
          "home": {
            "description": "Path to user's home directory",
            "type": "string"
          },
          "shell": {
            "description": "User's login shell",
            "type": "string"
          },
          "password": {
            "description": "User's encrypted password, as returned by crypt(3)",
            "type": "string"
          },
          "key": {
            "description": "SSH Public Key to add to ~/.ssh/authorized_keys",
            "type": "string"
          }
        }
      }
    }
  }
}
"""

def make_groups(groups: Dict) -> List[str]:
    # group --name NAME [--gid GID]

    res = []

    for name, opts in groups.items():
        gid = opts.get("gid")

        arguments = [f"group --name {name}"]
        if gid:
            arguments += ["--gid", str(gid)]

        res.append(" ".join(arguments))

    return res


def make_users(users: Dict) -> List[str]:
    # user [--homedir HOMEDIR] [--iscrypted] --name NAME [--password PASSWORD]
    # [--shell SHELL] [--uid INT] [--lock] [--plaintext] [--gecos GECOS]
    # [--gid INT] [--groups GROUPS]

    res = []

    for name, opts in users.items():

        arguments = [f"user --name {name}"]

        password = opts.get("password")
        if password is not None:
            arguments += ["--password", password or '""', "--iscrypted"]

        shell = opts.get("shell")
        if shell:
            arguments += ["--shell", shell]

        uid = opts.get("uid")
        if uid is not None:
            arguments += ["--uid", str(uid)]

        gid = opts.get("gid")
        if gid is not None:
            arguments += ["--gid", str(gid)]

        groups = opts.get("groups")
        if groups:
            arguments += ["--groups", ",".join(groups)]

        home = opts.get("home")
        if home:
            arguments += ["--homedir", home]

        res.append(" ".join(arguments))

        key = opts.get("key")
        if key:
            res.append(f'sshkey --username {name} "{key}"')

    return res


def make_ostree(ostree: Optional[Dict]) -> List[str]:
    if not ostree:
        return []

    osname, url, ref = ostree["osname"], ostree["url"], ostree["ref"]
    remote = ostree.get("remote")

    cmd = f"ostreesetup --osname={osname} --url={url} --ref={ref}"

    if remote:
        cmd += " --remote=" + remote
    if not ostree.get("gpg", True):
        cmd += " --nogpg"

    return [cmd]


def make_liveimg(liveimg: Optional[Dict]) -> List[str]:
    if not liveimg:
        return []

    url = liveimg["url"]
    return [f"liveimg --url {url}"]


def post_ostree(ostree: Optional[Dict]]) -> List[str]:
    if not ostree:
        return []

    return [
        'ostree admin set-origin --index 0 fedora-iot https://dl.fedoraproject.org/iot/repo/ "fedora/rawhide/${arch}/iot"',
        'ostree refs "fedora-iot:fedora/rawhide/${arch}/iot" --create "fedora-iot:fedora/rawhide/${arch}/iot"',
        'ostree remote delete fedora-iot',
        'ostree remote add --set=gpg-verify=true --set=gpgkeypath=/etc/pki/rpm-gpg/ --set=contenturl=mirrorlist=https://ostree.fedoraproject.org/iot/mirrorlist  fedora-iot "https://ostree.fedoraproject.org/iot"',
    ]


def main(tree, options):
    path = options["path"].lstrip("/")
    ostree = options.get("ostree")
    liveimg = options.get("liveimg")

    # Used to reconfigure ostree in the `post` section of the kickstart file,
    # this is necessary to update the remote as it is normally set to where
    # the initial commit is pulled from. If an installer is used that tends to
    # be the local filesystem which is incorrect.
    post_ostree= options.get("post_ostree")

    section_config = []

    section_config += make_ostree(ostree)
    section_config += make_liveimg(liveimg)
    section_config += make_groups(options.get("groups", {}))
    section_config += make_users(options.get("users", {}))

    section_post = []

    section_post += post_ostree(ostree_after_install)

    # If there's any post section set then we need to prepend its header
    if section_post:
        section_post = ["post --erroronfail"] + section_post

    target = os.path.join(tree, path)
    base = os.path.dirname(target)
    os.makedirs(base, exist_ok=True)

    with open(target, "w", encoding="utf8") as f:
        f.write("\n".join(section_config))
        f.write("\n")
        f.write("\n".join(section_post))

    print(f"created kickstart file at: {path}\n")

    with open(target, "r", encoding="utf8") as f:
        print(f.read())

    return 0


if __name__ == '__main__':
    args = osbuild.api.arguments()
    r = main(args["tree"], args["options"])
    sys.exit(r)
